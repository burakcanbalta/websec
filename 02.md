# SQL Injection

## SQL Injection Nedir?

SQL Injection, bir web uygulamasının kullanıcıdan aldığı verileri **doğrudan SQL sorgusu içine eklemesi** sonucu ortaya çıkan kritik bir güvenlik açığıdır.

Bu açık sayesinde saldırgan:
- Yetkisiz verilere erişebilir
- Kimlik doğrulamayı atlatabilir
- Verileri silebilir veya değiştirebilir
- Bazı durumlarda sunucuya kadar ilerleyebilir

SQL Injection, **OWASP Top 10** listesinde yıllardır en tehlikeli güvenlik açıklardan biridir.

---

## SQL Injection Nasıl Çalışır?

Tipik bir login sorgusu şu şekildedir:

```sql
SELECT * FROM users
WHERE username = 'kullanici' AND password = 'sifre';
```

Sorun şudur: **Kullanıcıdan gelen veri hiçbir kontrol yapılmadan sorguya gömülmektedir.**

Saldırgan aşağıdaki payload'u gönderirse:

```
' OR '1'='1
```

Oluşan gerçek sorgu:

```sql
SELECT * FROM users
WHERE username = '' OR '1'='1' AND password = '';
```

`'1'='1'` ifadesi her zaman **true** olduğu için parola kontrolü devre dışı kalır.

---

## SQL Injection Gerçek Hayatta Nerelerde Çıkar?

Yeni başlayanların en çok sorduğu soru şudur:
> "Tamam SQL Injection nedir anladım ama bunu nerede görürüm?"

Gerçek hayatta SQL Injection genellikle şu noktalarda karşımıza çıkar:

- Login ve register formları
- Arama kutuları (`?q=` gibi parametreler)
- URL parametreleri (`?id=1`)
- Filtreleme / sıralama alanları
- API body parametreleri (JSON)

Kısaca söylemek gerekirse:
**Kullanıcıdan veri alan ve bu veriyi veritabanına gönderen her yer potansiyel hedeftir.**

---

## SQL Injection Türleri

### 1. In-Band SQL Injection

Uygulama SQL hatasını veya sorgu sonucunu doğrudan kullanıcıya gösterir.

```
' OR 1=1 --
```

- En tehlikeli türdür
- Ancak tespiti en kolaydır

---

### 2. UNION Based SQL Injection

Başka tablolardan veri çekmek için kullanılır.

```
' UNION SELECT username, password FROM users --
```

Amaç:
- Kolon sayısını bulmak
- Hassas verileri çekmek

---

### 3. Blind SQL Injection

Uygulama hata veya sonucu ekrana basmaz.

Alt türleri:
- Boolean Based
- Time Based
- Out-of-Band (OAST)

**Time-Based örnek:**

```
' OR IF(1=1, SLEEP(5), 0) --
```

Sayfa gecikirse → SQL Injection vardır.

---

## SQL Sorgusu Nasıl Bozulur?

SQL Injection'ın temeli, **SQL mantığını kırmaktır**.

Kritik karakterler:
- `'` → String kapatır
- `--` → Sorgunun kalanını yorum satırı yapar
- `OR` → Mantıksal koşulu değiştirir

---

## Zafiyetli Flask + MySQL Uygulaması (Eğitim Amaçlı)

❌ **GÜVENSİZ KOD**

```python
from flask import Flask, request
import mysql.connector

app = Flask(__name__)

db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="testdb"
)

@app.route("/login", methods=["POST"])
def login():
    username = request.form["username"]
    password = request.form["password"]

    cursor = db.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    cursor.execute(query)

    result = cursor.fetchone()

    if result:
        return "Giriş başarılı"
    return "Hatalı bilgiler"

app.run(debug=True)
```

### Bu Kod Neden SQL Injection'a Açık?

Bu kodu bir saldırgan gözüyle okuduğunda sorunlar çok net görünür:

```python
username = request.form["username"]
password = request.form["password"]
```

Burada uygulama şunu yapıyor:
> "Kullanıcı ne gönderirse göndersin, ben aynen alırım."

Herhangi bir filtreleme, kontrol ya da sınırlama yok. Bu aşamada saldırgan için kapı tamamen açık.

---

```python
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```

Asıl kırılma noktası burası.

Red team açısından bakarsak:
- SQL sorgusu **string olarak birleştiriliyor**
- Kullanıcı girdisi sorgunun **birebir parçası hâline geliyor**
- Yani saldırgan sadece "veri" göndermiyor, **SQL yazıyor**

Bu noktadan sonra şunlar mümkün:
- `'` ile string'i kapatırım
- `OR` ile koşulu değiştiririm
- `--` ile password kontrolünü komple çöpe atarım

Uygulama şunu ayırt edemiyor:
> Bu gelen şey kullanıcı adı mı, yoksa SQL mantığı mı?

Ayırt edemediği için de **login bypass** kaçınılmaz oluyor.

---

### Neden Güvenli?

Şimdi güvenli koda bakalım:

```python
query = "SELECT * FROM users WHERE username = %s AND password = %s"
cursor.execute(query, (username, password))
```

Burada mimari tamamen değişiyor.

Red team olarak baktığında:
- SQL sorgusu **önceden tanımlı ve sabit**
- Benim gönderdiğim input, SQL'in yapısına **asla karışamıyor**

Veritabanının çalışma şekli şudur:
1. SQL sorgusunu derler (parse eder)
2. Sorgunun yapısını kilitler
3. Daha sonra input'u **sadece veri olarak** yerleştirir

Yani ben şunu göndersem bile:

```
' OR 1=1 --
```

Veritabanı bunu şöyle algılar:
> "Bu bir kullanıcı adı string'i, SQL değil"

Sonuç:
- `'` artık string kapatamaz
- `OR` mantığı değiştiremez
- `--` yorum satırı olamaz

Red team açısından söyleyeyim:
> Burada payload yazsan da çalışmaz, çünkü oynayabileceğin bir SQL mantığı kalmamıştır.

---

---

## SQL Injection Nasıl Exploit Edilir?

**Username alanına:**

```
' OR 1=1 --
```

**Oluşan sorgu:**

```sql
SELECT * FROM users WHERE username = '' OR 1=1 -- ' AND password = '';
```

- `OR 1=1` → Her zaman true
- `--` → Password kontrolü iptal

**Sonuç:** Login bypass

---

## Secure Versiyon

✅ **GÜVENLİ KOD**

```python
@app.route("/login", methods=["POST"])
def secure_login():
    username = request.form["username"]
    password = request.form["password"]

    cursor = db.cursor(prepared=True)
    query = "SELECT * FROM users WHERE username = %s AND password = %s"
    cursor.execute(query, (username, password))

    result = cursor.fetchone()

    if result:
        return "Giriş başarılı"
    return "Hatalı bilgiler"
```

### Neden Güvenli?
- SQL yapısı sabittir
- Kullanıcı girdisi SQL'in parçası değildir
- Veritabanı input'u yalnızca veri olarak işler

---

## ORM Kullanımı

### ORM Nedir?

ORM (Object Relational Mapping), **veritabanı tablolarını uygulama içindeki nesnelere (class)** dönüştüren bir yaklaşımdır.

Yani:
- Tablo → Class
- Satır → Object
- Kolon → Attribute

Geliştirici SQL yazmak yerine, **nesneler üzerinden veriyle çalışır**.

---

### SQL Olmadan Veri Çekme Mantığı

SQL yazmadan yapılan bir işlem:

```python
user = User.query.filter_by(username=username).first()
```

ORM bunu arka planda güvenli bir SQL sorgusuna çevirir:

```sql
SELECT * FROM users WHERE username = %s LIMIT 1;
```

Ama bu SQL'i **sen yazmazsın**, ORM üretir.

---

### Neden ORM SQL Injection'a Karşı Güvenlidir?

- Manuel SQL yazılmaz
- Parametre binding otomatik yapılır
- Kullanıcı girdisi SQL mantığına karışmaz
- `' OR 1=1 --` gibi payload'lar sadece string olarak algılanır

Bu yüzden ORM kullanıldığında SQL Injection ihtimali **pratikte sıfıra yakındır**.

---

### ORM Ne Zaman Risklidir?

ORM kullanılsa bile şu durumlar risklidir:

```python
db.session.execute(f"SELECT * FROM users WHERE username = '{username}'")
```

Bu durumda ORM bypass edilir ve **tekrar SQL Injection riski doğar**.

---

## SQL Injection Türleri Nasıl Anlaşılır?

Bir uygulamada SQL Injection olup olmadığını ve **hangi tür olduğunu anlamak**, payload ezberlemekten daha önemlidir.

---

### 1. In-Band SQL Injection Nasıl Anlaşılır?

**Belirti:**
- Hata yok
- Veri görünmüyor
- Sayfa aynı görünüyor

Blind SQL Injection'da uygulama:
- Hata mesajlarını gizler
- Sorgu sonucunu kullanıcıya göstermez

Bu yüzden saldırgan,
veriyi değil **uygulamanın davranışını** gözlemler.

#### Boolean-Based Blind

Test:
```
' OR 1=1 --
' OR 1=2 --
```

Eğer iki sorgunun **sayfa cevabı farklıysa**:
→ Boolean-Based Blind SQLi vardır.

---

#### Time-Based Blind

Test:
```
' OR IF(1=1, SLEEP(5), 0) --
```

Eğer:
- Sayfa 5 saniye geç dönüyorsa

→ Time-Based SQL Injection vardır.

---

### Hangisi Varsa Hangisi Yok?

| Belirti | Tür |
|------|----|
| SQL hatası görünüyor | In-Band |
| UNION ile veri geliyor | UNION-Based |
| Sayfa farkı var | Boolean-Based Blind |
| Gecikme var | Time-Based Blind |

---

---

## SQL Injection Nasıl Tespit Edilir?

Manuel test yaklaşımı:
- `'` gönder → hata var mı?
- `OR 1=1` vs `OR 1=2` farkı
- Time-based payload ile gecikme ölçümü
- UNION ile kolon sayısı denemeleri

---

## Burp Suite & PortSwigger Yaklaşımı

- Request yakalama
- Parametre bazlı testler
- Response farkı analizi

**PortSwigger Web Security Academy**:
- Gerçekçi lablar
- Mantık odaklı ilerleme
- Ezber payload yok

---

## Yaygın SQL Injection Senaryoları

**Login Bypass**
```
administrator' --
```

**Tüm verileri çekme**
```
' OR 1=1 --
```

**Tablo keşfi**
```
' UNION SELECT table_name, null FROM information_schema.tables --
```

---

## SQL Injection'dan Korunma

Yapılması gerekenler:
- Prepared Statements
- ORM kullanımı
- Least privilege database user
- Hata mesajlarını gizleme

❌ **Tek başına input validation yeterli değildir**

Sadece:
- `'` engellemek
- `OR` silmek

SQL Injection'ı gerçekten çözmez.

Gerçek çözüm:
✔ Prepared Statement
✔ ORM

---

## Veritabanı Türüne Göre SQL Injection Davranışı

SQL Injection mantığı her veritabanında aynıdır,
ancak **syntax ve payload'lar değişir**.

### MySQL
- `SLEEP(5)` time-based için yaygındır
- `information_schema` aktif kullanılır

### MSSQL
- `WAITFOR DELAY '0:0:5'` kullanılır
- `--` ve `/* */` yorumları yaygındır

### PostgreSQL
- `pg_sleep(5)` time-based için kullanılır
- UNION ve CAST işlemleri daha katıdır

### Oracle
- `SELECT banner FROM v$version` gibi özel tablolar vardır
- Genellikle `DUAL` tablosu kullanılır

Not:
Mantık aynıdır, **sadece yazım şekli değişir**.

---

## Framework'lere Göre Genel Davranış

### PHP (Eski / Custom Kodlar)
- SQL Injection en sık görülen ortam
- String birleştirme çok yaygın

### Flask / Django
- Raw SQL kullanılırsa risk vardır
- ORM kullanıldığında büyük ölçüde güvenlidir

### Node.js
- `mysql`, `sequelize` gibi paketlerde raw query risklidir
- Prepared query kullanımı şarttır

### Java (Spring)
- `JdbcTemplate` raw kullanılırsa risk oluşur
- JPA / Hibernate genelde güvenlidir

---

## Sonuç

SQL Injection öğrenirken önemli olan:
**payload ezberlemek değil, SQL'in neden kırıldığını anlamaktır**.

Bu bakış açısı:
- Pentest
- Bug bounty
- Secure coding

için seni bir üst seviyeye taşır.


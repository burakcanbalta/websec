# SQL Injection

## SQL Injection Nedir?

SQL Injection, bir web uygulamasının kullanıcıdan aldığı verileri **doğrudan SQL sorgusu içine eklemesi** sonucu ortaya çıkan kritik bir güvenlik açığıdır. Bu açık sayesinde saldırgan:

- Yetkisiz verilere erişebilir
- Kimlik doğrulamayı atlatabilir
- Verileri silebilir veya değiştirebilir
- Bazı durumlarda sunucuya kadar ilerleyebilir

SQL Injection, **OWASP Top 10** listesinde yıllardır en tehlikeli güvenlik açıklardan biridir.

---

## SQL Injection Gerçek Hayatta Nerelerde Çıkar?

Kısa ve net: kullanıcı girdisi alınıp veritabanına gönderilen her yer potansiyel hedeftir. Örnekler:

- Login formları (kullanıcı adı / parola alanları)
- Arama kutuları (ör. `?q=term`)
- URL parametreleri (ör. `?id=1`)
- Filtreleme / sıralama alanları (ör. `?sort=price`)
- API parametreleri (query string veya path)
- API body parametreleri (JSON içinde gelen alanlar)
- Yönetici panelleri, raporlama endpoint'leri, import/CSV işleme bölümleri

Kısaca: **Kullanıcıdan veri alan ve veritabanına giden her yer potansiyel hedeftir.** Bu bölüm hiç bilmeyenler için zihni oturtur.

---

## SQL Injection Nasıl Çalışır?

Tipik bir login sorgusu şu şekildedir:

```sql
SELECT * FROM users WHERE username = 'kullanici' AND password = 'sifre';
```

Sorun şudur: **Kullanıcıdan gelen veri hiçbir kontrol yapılmadan sorguya gömülmektedir.**

Saldırgan aşağıdaki payload'u gönderirse: `' OR '1'='1` oluşan gerçek sorgu:

```sql
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '';
```

`'1'='1'` ifadesi her zaman **true** olduğu için parola kontrolü devre dışı kalır.

---

## SQL Injection Türleri

### 1. In-Band SQL Injection

Uygulama SQL hatasını veya sorgu sonucunu doğrudan kullanıcıya gösterir.

`' OR 1=1 --`

- En tehlikeli türdür
- Ancak tespiti en kolaydır

---

### 2. UNION Based SQL Injection

Başka tablolardan veri çekmek için kullanılır.

`' UNION SELECT username, password FROM users --`

Amaç:

- Kolon sayısını bulmak
- Hassas verileri çekmek

**ORDER BY notu (neden `ORDER BY` deniyoruz?)**

`ORDER BY` burada veri sıralamak için değil, **kaç kolon olduğunu anlamak için** kullanılır. Örnek:

- `ORDER BY 1` → 1 kolon var mı?
- `ORDER BY 2` → 2 kolon var mı?

Eğer bir `ORDER BY N` denediğinde hata alıyorsan, N mevcut kolon sayısını aşmış demektir. Bu yöntem kolon sayısını tespit etmek için hızlı ve güvenlidir; bu yüzden UNION denemelerinden önce sıklıkla kullanılır.

---

### 3. Blind SQL Injection

Uygulama hata veya sonucu ekrana basmaz. Alt türleri:

- Boolean-Based
- Time-Based
- Out-of-Band (OAST)

**Niye hiçbir şey görünmüyor? — "Niye hata da veri de yok?"**

Blind SQLi durumunda uygulama genellikle:

- Hata mesajlarını gizler
- Sorgu sonucunu kullanıcıya göstermez

Bu yüzden saldırgan, veriyi doğrudan değil **uygulamanın davranışını** gözlemler (ör. sayfa cevabı değişiyor mu, gecikme oluyor mu, farklı bir HTTP kodu dönüyor mu). Bu davranış-tabanlı gözlemler veri sızdırmak için kullanılır.

**Time-Based örnek:**

```sql
' OR IF(1=1, SLEEP(5), 0) --
```

Sayfa 5 saniye gecikirse → SQL Injection vardır.

---

## SQL Sorgusu Nasıl Bozulur?

SQL Injection'ın temeli, **SQL mantığını kırmaktır**. Kritik karakterler:

- `'` → String kapatır
- `--` → Sorgunun kalanını yorum satırı yapar
- `OR` → Mantıksal koşulu değiştirir

---

## Zafiyetli Flask + MySQL Uygulaması

❌ **GÜVENSİZ KOD**

```python
from flask import Flask, request
import mysql.connector

app = Flask(__name__)

db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="testdb"
)

@app.route("/login", methods=["POST"])
def login():
    username = request.form["username"]
    password = request.form["password"]
    cursor = db.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    cursor.execute(query)
    result = cursor.fetchone()
    if result:
        return "Giriş başarılı"
    return "Hatalı bilgiler"

app.run(debug=True)
```

### Bu Kod Neden SQL Injection'a Açık?

Bu kodu bir saldırgan gözüyle okuduğunda sorunlar çok net görünür: `username`/`password` doğrudan SQL içine gömülüyor. Herhangi bir filtreleme, kontrol ya da sınırlama yok.

---

### Neden Güvenli?

```python
query = "SELECT * FROM users WHERE username = %s AND password = %s"
cursor.execute(query, (username, password))
```

Burada mimari tamamen değişiyor:

- SQL sorgusu **önceden tanımlı ve sabit**
- Kullanıcı input'u **sadece veri** olarak işleniyor

Sonuç: payload'lar SQL mantığını kıramaz.

---

## ORM Kullanımı

ORM (Object Relational Mapping), veritabanı tablolarını uygulama içindeki nesnelere dönüştürür. ORM kullanıldığında parametre binding otomatik yapılır, manuel SQL yazılmadığı sürece SQL Injection riski büyük ölçüde azalır.

Ancak dikkat: ORM içinde raw/execute ile dinamik SQL yazmak riski geri getirir.

---

## SQL Injection Türleri Nasıl Anlaşılır?

... (orijinal içerik devam ediyor)

---

## Savunma: "Ne Yapılmalı" ve "Ne İşe Yaramaz"

**Ne işe yarar (özet):**

- Prepared statements / parametrized queries
- ORM (doğru kullanıldığında)
- Stored procedures (parametreli, dikkatle)
- Minimal yetki prensibi (DB kullanıcılarının yetkilerini kısıtla)
- Web application firewall (WAF) — ek bir savunma katmanı
- Güvenli kod tarama / SAST / DAST testleri

**Ne işe yaramaz — kritik uyarı:**

❌ **Tek başına input validation yeterli değildir.**

Sadece `'` karakterini engellemek ya da `OR` kelimesini filtrelemek genelde işe yaramaz; saldırgan farklı yollar bulur (ör. encoding, comment tricks, farklı payload yapıları).

Gerçek çözüm:

✔ Prepared Statement (parametrized queries)
✔ ORM (manuel raw SQL kullanılmadığı sürece)

Bu tespit, yeni başlayanların sık yaptığı yanlışları engeller: "input validation = çözüm" mantığı yanlıştır.

---

## MySQL / MSSQL / PostgreSQL Farkları (Kısa Notlar)

Payload'lar veritabanına göre değişebilir — mantık aynı olsa da syntax farklıdır. Örnek farklar:

- **MySQL:** `SLEEP(5)` ve `IF(cond, SLEEP(5), 0)` sık kullanılır.
- **MSSQL (SQL Server):** `WAITFOR DELAY '0:0:5'` ya da `IF cond BEGIN WAITFOR DELAY '00:00:05' END` gibi ifadeler.
- **PostgreSQL:** `pg_sleep(5)` fonksiyonu kullanılır.

Ayrıca bilgi şeması isimleri farklılık gösterebilir (`information_schema` çoğunlukla ortak olsa da, detay sütun adları değişebilir).

---

## Framework Davranışları — Kısa Karşılaştırma

- **Django (Python):** Varsayılan olarak ORM (QuerySet) kullanır; parametrized SQL üretir. Ancak `raw()` veya `connection.execute()` ile dinamik SQL yazarsan risk açılır.
- **Flask (Python) + mysql-connector / pymysql:** ORM yoksa geliştiricinin parametrized query kullanması gerekir; f-string veya string concat tehlikelidir.
- **Express (Node.js) + mysql / pg:** Sürücülerin `query(text, params)` şeklindeki parametrizasyonunu kullan; string interpolation tehlikelidir.
- **PHP (plain) + MySQLi / PDO:** PDO ile prepared statements kullan; eski `mysql_*` fonksiyonları veya stringle birleştirme tehlikelidir.
- **.NET (C#) + SqlClient / Entity Framework:** `SqlParameter` veya EF parametrizasyonu kullanılır; `ExecuteSqlRaw`/`FromSqlRaw` dikkat gerektirir.

Genel kural: **ORM veya sürücünün parametrizasyon mekanizması kullanılmalı; raw/dinamik SQL dikkatle incelenmeli.**

---

## Örnek Yaygın Senaryolar

- Login bypass: `administrator' --`
- Tüm verileri çekme: `' OR 1=1 --`
- Tablo keşfi: `' UNION SELECT table_name, null FROM information_schema.tables --`

---

## Sonuç — Kısa Özet

- SQL Injection, kullanıcı girdisinin SQL yapısına karıştığı her yerde ortaya çıkabilir.
- Input validation yardımcıdır ama tek başına çözüm değildir.
- Parametrized queries / prepared statements / ORM en etkili savunmalardır.
- Payload'lar kullandığın veritabanına göre değişir — MySQL, MSSQL, PostgreSQL arasında syntax farklılıkları vardır.

---

*Not: Belirttiğiniz küçük eklemeler ve database/framework uyaruları eklendi. Orijinal metni mümkün olduğunca değiştirmedim; yalnızca istenen başlıkları ve kısa açıklamaları ekledim.*


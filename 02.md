# SQL Injection

## SQL Injection Nedir?

SQL Injection, bir web uygulamasÄ±nÄ±n kullanÄ±cÄ±dan aldÄ±ÄŸÄ± verileri **doÄŸrudan SQL sorgusu iÃ§ine eklemesi** sonucu ortaya Ã§Ä±kan kritik bir gÃ¼venlik aÃ§Ä±ÄŸÄ±dÄ±r.

Bu aÃ§Ä±k sayesinde saldÄ±rgan:
- Yetkisiz verilere eriÅŸebilir
- Kimlik doÄŸrulamayÄ± atlatabilir
- Verileri silebilir veya deÄŸiÅŸtirebilir
- BazÄ± durumlarda sunucuya kadar ilerleyebilir

SQL Injection, **OWASP Top 10** listesinde yÄ±llardÄ±r en tehlikeli gÃ¼venlik aÃ§Ä±klardan biridir.

---

## SQL Injection NasÄ±l Ã‡alÄ±ÅŸÄ±r?

Tipik bir login sorgusu ÅŸu ÅŸekildedir:

```sql
SELECT * FROM users
WHERE username = 'kullanici' AND password = 'sifre';
```

Sorun ÅŸudur: **KullanÄ±cÄ±dan gelen veri hiÃ§bir kontrol yapÄ±lmadan sorguya gÃ¶mÃ¼lmektedir.**

SaldÄ±rgan aÅŸaÄŸÄ±daki payload'u gÃ¶nderirse:

```
' OR '1'='1
```

OluÅŸan gerÃ§ek sorgu:

```sql
SELECT * FROM users
WHERE username = '' OR '1'='1' AND password = '';
```

`'1'='1'` ifadesi her zaman **true** olduÄŸu iÃ§in parola kontrolÃ¼ devre dÄ±ÅŸÄ± kalÄ±r.

---

## SQL Injection GerÃ§ek Hayatta Nerelerde Ã‡Ä±kar?

Yeni baÅŸlayanlarÄ±n en Ã§ok sorduÄŸu soru ÅŸudur:
> "Tamam SQL Injection nedir anladÄ±m ama bunu nerede gÃ¶rÃ¼rÃ¼m?"

GerÃ§ek hayatta SQL Injection genellikle ÅŸu noktalarda karÅŸÄ±mÄ±za Ã§Ä±kar:

- Login ve register formlarÄ±
- Arama kutularÄ± (`?q=` gibi parametreler)
- URL parametreleri (`?id=1`)
- Filtreleme / sÄ±ralama alanlarÄ±
- API body parametreleri (JSON)

KÄ±saca sÃ¶ylemek gerekirse:
**KullanÄ±cÄ±dan veri alan ve bu veriyi veritabanÄ±na gÃ¶nderen her yer potansiyel hedeftir.**

---

## SQL Injection TÃ¼rleri

### 1. In-Band SQL Injection

Uygulama SQL hatasÄ±nÄ± veya sorgu sonucunu doÄŸrudan kullanÄ±cÄ±ya gÃ¶sterir.

```
' OR 1=1 --
```

- En tehlikeli tÃ¼rdÃ¼r
- Ancak tespiti en kolaydÄ±r

---

### 2. UNION Based SQL Injection

BaÅŸka tablolardan veri Ã§ekmek iÃ§in kullanÄ±lÄ±r.

```
' UNION SELECT username, password FROM users --
```

AmaÃ§:
- Kolon sayÄ±sÄ±nÄ± bulmak
- Hassas verileri Ã§ekmek

---

### 3. Blind SQL Injection

Uygulama hata veya sonucu ekrana basmaz.

Alt tÃ¼rleri:
- Boolean Based
- Time Based
- Out-of-Band (OAST)

**Time-Based Ã¶rnek:**

```
' OR IF(1=1, SLEEP(5), 0) --
```

Sayfa gecikirse â†’ SQL Injection vardÄ±r.

---

## SQL Sorgusu NasÄ±l Bozulur?

SQL Injection'Ä±n temeli, **SQL mantÄ±ÄŸÄ±nÄ± kÄ±rmaktÄ±r**.

Kritik karakterler:
- `'` â†’ String kapatÄ±r
- `--` â†’ Sorgunun kalanÄ±nÄ± yorum satÄ±rÄ± yapar
- `OR` â†’ MantÄ±ksal koÅŸulu deÄŸiÅŸtirir

### ğŸ“¸ GÃ¶rsel Yerleri
- Basit `users` tablosu diyagramÄ±
- Normal SQL sorgusu akÄ±ÅŸÄ±
- `'` karakteriyle sorgunun kÄ±rÄ±lmasÄ±
- `--` ile password kontrolÃ¼nÃ¼n iptali

---

## Zafiyetli Flask + MySQL UygulamasÄ± (EÄŸitim AmaÃ§lÄ±)

âŒ **GÃœVENSÄ°Z KOD**

```python
from flask import Flask, request
import mysql.connector

app = Flask(__name__)

db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="testdb"
)

@app.route("/login", methods=["POST"])
def login():
    username = request.form["username"]
    password = request.form["password"]

    cursor = db.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    cursor.execute(query)

    result = cursor.fetchone()

    if result:
        return "GiriÅŸ baÅŸarÄ±lÄ±"
    return "HatalÄ± bilgiler"

app.run(debug=True)
```

### Bu Kod Neden SQL Injection'a AÃ§Ä±k? (Red Team Yorumu)

Bu kodu bir saldÄ±rgan gÃ¶zÃ¼yle okuduÄŸunda sorunlar Ã§ok net gÃ¶rÃ¼nÃ¼r:

```python
username = request.form["username"]
password = request.form["password"]
```

Burada uygulama ÅŸunu yapÄ±yor:
> "KullanÄ±cÄ± ne gÃ¶nderirse gÃ¶ndersin, ben aynen alÄ±rÄ±m."

Herhangi bir filtreleme, kontrol ya da sÄ±nÄ±rlama yok. Bu aÅŸamada saldÄ±rgan iÃ§in kapÄ± tamamen aÃ§Ä±k.

---

```python
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```

AsÄ±l kÄ±rÄ±lma noktasÄ± burasÄ±.

Red team aÃ§Ä±sÄ±ndan bakarsak:
- SQL sorgusu **string olarak birleÅŸtiriliyor**
- KullanÄ±cÄ± girdisi sorgunun **birebir parÃ§asÄ± hÃ¢line geliyor**
- Yani saldÄ±rgan sadece "veri" gÃ¶ndermiyor, **SQL yazÄ±yor**

Bu noktadan sonra ÅŸunlar mÃ¼mkÃ¼n:
- `'` ile string'i kapatÄ±rÄ±m
- `OR` ile koÅŸulu deÄŸiÅŸtiririm
- `--` ile password kontrolÃ¼nÃ¼ komple Ã§Ã¶pe atarÄ±m

Uygulama ÅŸunu ayÄ±rt edemiyor:
> Bu gelen ÅŸey kullanÄ±cÄ± adÄ± mÄ±, yoksa SQL mantÄ±ÄŸÄ± mÄ±?

AyÄ±rt edemediÄŸi iÃ§in de **login bypass** kaÃ§Ä±nÄ±lmaz oluyor.

---

### Neden GÃ¼venli? (Prepared Statement â€“ Blue Team BakÄ±ÅŸÄ±)

Åimdi gÃ¼venli koda bakalÄ±m:

```python
query = "SELECT * FROM users WHERE username = %s AND password = %s"
cursor.execute(query, (username, password))
```

Burada mimari tamamen deÄŸiÅŸiyor.

Red team olarak baktÄ±ÄŸÄ±nda:
- SQL sorgusu **Ã¶nceden tanÄ±mlÄ± ve sabit**
- Benim gÃ¶nderdiÄŸim input, SQL'in yapÄ±sÄ±na **asla karÄ±ÅŸamÄ±yor**

VeritabanÄ±nÄ±n Ã§alÄ±ÅŸma ÅŸekli ÅŸudur:
1. SQL sorgusunu derler (parse eder)
2. Sorgunun yapÄ±sÄ±nÄ± kilitler
3. Daha sonra input'u **sadece veri olarak** yerleÅŸtirir

Yani ben ÅŸunu gÃ¶ndersem bile:

```
' OR 1=1 --
```

VeritabanÄ± bunu ÅŸÃ¶yle algÄ±lar:
> "Bu bir kullanÄ±cÄ± adÄ± string'i, SQL deÄŸil"

SonuÃ§:
- `'` artÄ±k string kapatamaz
- `OR` mantÄ±ÄŸÄ± deÄŸiÅŸtiremez
- `--` yorum satÄ±rÄ± olamaz

Red team aÃ§Ä±sÄ±ndan sÃ¶yleyeyim:
> Burada payload yazsan da Ã§alÄ±ÅŸmaz, Ã§Ã¼nkÃ¼ oynayabileceÄŸin bir SQL mantÄ±ÄŸÄ± kalmamÄ±ÅŸtÄ±r.

---

---

## SQL Injection NasÄ±l Exploit Edilir?

**Username alanÄ±na:**

```
' OR 1=1 --
```

**OluÅŸan sorgu:**

```sql
SELECT * FROM users WHERE username = '' OR 1=1 -- ' AND password = '';
```

- `OR 1=1` â†’ Her zaman true
- `--` â†’ Password kontrolÃ¼ iptal

**SonuÃ§:** Login bypass

---

## Secure Versiyon â€“ Prepared Statement

âœ… **GÃœVENLÄ° KOD**

```python
@app.route("/login", methods=["POST"])
def secure_login():
    username = request.form["username"]
    password = request.form["password"]

    cursor = db.cursor(prepared=True)
    query = "SELECT * FROM users WHERE username = %s AND password = %s"
    cursor.execute(query, (username, password))

    result = cursor.fetchone()

    if result:
        return "GiriÅŸ baÅŸarÄ±lÄ±"
    return "HatalÄ± bilgiler"
```

### Neden GÃ¼venli?
- SQL yapÄ±sÄ± sabittir
- KullanÄ±cÄ± girdisi SQL'in parÃ§asÄ± deÄŸildir
- VeritabanÄ± input'u yalnÄ±zca veri olarak iÅŸler

---

## ORM KullanÄ±mÄ± (En GÃ¼venli YaklaÅŸÄ±m)

### ORM Nedir?

ORM (Object Relational Mapping), **veritabanÄ± tablolarÄ±nÄ± uygulama iÃ§indeki nesnelere (class)** dÃ¶nÃ¼ÅŸtÃ¼ren bir yaklaÅŸÄ±mdÄ±r.

Yani:
- Tablo â†’ Class
- SatÄ±r â†’ Object
- Kolon â†’ Attribute

GeliÅŸtirici SQL yazmak yerine, **nesneler Ã¼zerinden veriyle Ã§alÄ±ÅŸÄ±r**.

---

### SQL Olmadan Veri Ã‡ekme MantÄ±ÄŸÄ±

SQL yazmadan yapÄ±lan bir iÅŸlem:

```python
user = User.query.filter_by(username=username).first()
```

ORM bunu arka planda gÃ¼venli bir SQL sorgusuna Ã§evirir:

```sql
SELECT * FROM users WHERE username = %s LIMIT 1;
```

Ama bu SQL'i **sen yazmazsÄ±n**, ORM Ã¼retir.

---

### Neden ORM SQL Injection'a KarÅŸÄ± GÃ¼venlidir?

- Manuel SQL yazÄ±lmaz
- Parametre binding otomatik yapÄ±lÄ±r
- KullanÄ±cÄ± girdisi SQL mantÄ±ÄŸÄ±na karÄ±ÅŸmaz
- `' OR 1=1 --` gibi payload'lar sadece string olarak algÄ±lanÄ±r

Bu yÃ¼zden ORM kullanÄ±ldÄ±ÄŸÄ±nda SQL Injection ihtimali **pratikte sÄ±fÄ±ra yakÄ±ndÄ±r**.

---

### ORM Ne Zaman Risklidir?

ORM kullanÄ±lsa bile ÅŸu durumlar risklidir:

```python
db.session.execute(f"SELECT * FROM users WHERE username = '{username}'")
```

Bu durumda ORM bypass edilir ve **tekrar SQL Injection riski doÄŸar**.

---

## SQL Injection TÃ¼rleri NasÄ±l AnlaÅŸÄ±lÄ±r?

Bir uygulamada SQL Injection olup olmadÄ±ÄŸÄ±nÄ± ve **hangi tÃ¼r olduÄŸunu anlamak**, payload ezberlemekten daha Ã¶nemlidir.

---

### 1. In-Band SQL Injection NasÄ±l AnlaÅŸÄ±lÄ±r?

**Belirti:**
- Hata yok
- Veri gÃ¶rÃ¼nmÃ¼yor
- Sayfa aynÄ± gÃ¶rÃ¼nÃ¼yor

Blind SQL Injection'da uygulama:
- Hata mesajlarÄ±nÄ± gizler
- Sorgu sonucunu kullanÄ±cÄ±ya gÃ¶stermez

Bu yÃ¼zden saldÄ±rgan,
veriyi deÄŸil **uygulamanÄ±n davranÄ±ÅŸÄ±nÄ±** gÃ¶zlemler.

#### Boolean-Based Blind

Test:
```
' OR 1=1 --
' OR 1=2 --
```

EÄŸer iki sorgunun **sayfa cevabÄ± farklÄ±ysa**:
â†’ Boolean-Based Blind SQLi vardÄ±r.

---

#### Time-Based Blind

Test:
```
' OR IF(1=1, SLEEP(5), 0) --
```

EÄŸer:
- Sayfa 5 saniye geÃ§ dÃ¶nÃ¼yorsa

â†’ Time-Based SQL Injection vardÄ±r.

---

### Hangisi Varsa Hangisi Yok?

| Belirti | TÃ¼r |
|------|----|
| SQL hatasÄ± gÃ¶rÃ¼nÃ¼yor | In-Band |
| UNION ile veri geliyor | UNION-Based |
| Sayfa farkÄ± var | Boolean-Based Blind |
| Gecikme var | Time-Based Blind |

---

---

## SQL Injection NasÄ±l Tespit Edilir?

Manuel test yaklaÅŸÄ±mÄ±:
- `'` gÃ¶nder â†’ hata var mÄ±?
- `OR 1=1` vs `OR 1=2` farkÄ±
- Time-based payload ile gecikme Ã¶lÃ§Ã¼mÃ¼
- UNION ile kolon sayÄ±sÄ± denemeleri

---

## Burp Suite & PortSwigger YaklaÅŸÄ±mÄ±

- Request yakalama
- Parametre bazlÄ± testler
- Response farkÄ± analizi

**PortSwigger Web Security Academy**:
- GerÃ§ekÃ§i lablar
- MantÄ±k odaklÄ± ilerleme
- Ezber payload yok

---

## YaygÄ±n SQL Injection SenaryolarÄ±

**Login Bypass**
```
administrator' --
```

**TÃ¼m verileri Ã§ekme**
```
' OR 1=1 --
```

**Tablo keÅŸfi**
```
' UNION SELECT table_name, null FROM information_schema.tables --
```

---

## SQL Injection'dan Korunma

YapÄ±lmasÄ± gerekenler:
- Prepared Statements
- ORM kullanÄ±mÄ±
- Least privilege database user
- Hata mesajlarÄ±nÄ± gizleme

âŒ **Tek baÅŸÄ±na input validation yeterli deÄŸildir**

Sadece:
- `'` engellemek
- `OR` silmek

SQL Injection'Ä± gerÃ§ekten Ã§Ã¶zmez.

GerÃ§ek Ã§Ã¶zÃ¼m:
âœ” Prepared Statement
âœ” ORM

---

## VeritabanÄ± TÃ¼rÃ¼ne GÃ¶re SQL Injection DavranÄ±ÅŸÄ±

SQL Injection mantÄ±ÄŸÄ± her veritabanÄ±nda aynÄ±dÄ±r,
ancak **syntax ve payload'lar deÄŸiÅŸir**.

### MySQL
- `SLEEP(5)` time-based iÃ§in yaygÄ±ndÄ±r
- `information_schema` aktif kullanÄ±lÄ±r

### MSSQL
- `WAITFOR DELAY '0:0:5'` kullanÄ±lÄ±r
- `--` ve `/* */` yorumlarÄ± yaygÄ±ndÄ±r

### PostgreSQL
- `pg_sleep(5)` time-based iÃ§in kullanÄ±lÄ±r
- UNION ve CAST iÅŸlemleri daha katÄ±dÄ±r

### Oracle
- `SELECT banner FROM v$version` gibi Ã¶zel tablolar vardÄ±r
- Genellikle `DUAL` tablosu kullanÄ±lÄ±r

Not:
MantÄ±k aynÄ±dÄ±r, **sadece yazÄ±m ÅŸekli deÄŸiÅŸir**.

---

## Framework'lere GÃ¶re Genel DavranÄ±ÅŸ

### PHP (Eski / Custom Kodlar)
- SQL Injection en sÄ±k gÃ¶rÃ¼len ortam
- String birleÅŸtirme Ã§ok yaygÄ±n

### Flask / Django
- Raw SQL kullanÄ±lÄ±rsa risk vardÄ±r
- ORM kullanÄ±ldÄ±ÄŸÄ±nda bÃ¼yÃ¼k Ã¶lÃ§Ã¼de gÃ¼venlidir

### Node.js
- `mysql`, `sequelize` gibi paketlerde raw query risklidir
- Prepared query kullanÄ±mÄ± ÅŸarttÄ±r

### Java (Spring)
- `JdbcTemplate` raw kullanÄ±lÄ±rsa risk oluÅŸur
- JPA / Hibernate genelde gÃ¼venlidir

---

## SonuÃ§

SQL Injection Ã¶ÄŸrenirken Ã¶nemli olan:
**payload ezberlemek deÄŸil, SQL'in neden kÄ±rÄ±ldÄ±ÄŸÄ±nÄ± anlamaktÄ±r**.

Bu bakÄ±ÅŸ aÃ§Ä±sÄ±:
- Pentest
- Bug bounty
- Secure coding

iÃ§in seni bir Ã¼st seviyeye taÅŸÄ±r.


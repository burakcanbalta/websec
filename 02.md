# SQL Injection

## SQL Injection Nedir?

SQL Injection, bir web uygulamasının kullanıcıdan aldığı verileri **doğrudan SQL sorgusu içine eklemesi** sonucu ortaya çıkan kritik bir güvenlik açığıdır. Bu açık sayesinde saldırgan:

* Yetkisiz verilere erişebilir
* Kimlik doğrulamayı atlatabilir
* Verileri silebilir veya değiştirebilir
* Bazı durumlarda veritabanı sunucusu üzerinden sisteme daha derin erişim elde edebilir

SQL Injection, **OWASP Top 10** listesinde uzun yıllardır yer alan ve hâlâ gerçek sistemlerde sıkça görülen bir zafiyettir. Bunun en büyük sebebi, hatanın genellikle **mantıksal** olması ve geliştiriciler tarafından gözden kaçırılmasıdır.

---

## SQL Injection Gerçek Hayatta Nerelerde Çıkar?

Kısa cevap: **Kullanıcıdan veri alıp veritabanına gönderen her yer potansiyel hedeftir.**

En sık karşılaşılan alanlar:

* Login formları (kullanıcı adı / parola)
* Arama kutuları (`?q=search`)
* URL parametreleri (`?id=1`)
* Filtreleme ve sıralama alanları (`?sort=price`)
* API endpoint’leri (query string, path parametreleri)
* API body içinde gelen JSON alanları
* Admin panelleri
* Raporlama, export/import ve CSV işleme bölümleri

Özetle: **Bir input SQL’e gidiyorsa, orada SQL Injection riski vardır.**
Bu bakış açısı, konuyu ilk kez öğrenenlerin zihninde doğru temeli oluşturur.

---

## SQL Injection Nasıl Çalışır?

Tipik bir login sorgusu şu şekildedir:

```sql
SELECT * FROM users 
WHERE username = 'kullanici' AND password = 'sifre';
```

Buradaki temel problem şudur:

> **Kullanıcıdan gelen veri, hiçbir ayrıştırma veya sınırlandırma olmadan SQL sorgusunun içine eklenmiştir.**

Eğer saldırgan şu payload’u gönderirse:

```text
' OR '1'='1
```

Oluşan gerçek SQL sorgusu şuna dönüşür:

```sql
SELECT * FROM users 
WHERE username = '' OR '1'='1' AND password = '';
```

`'1'='1'` ifadesi **her zaman true** olduğu için parola kontrolü devre dışı kalır ve sistem saldırganı yetkili kullanıcı gibi kabul eder.

---

## SQL Injection Türleri

### 1. In-Band SQL Injection

Uygulama, SQL hatalarını veya sorgu sonuçlarını doğrudan kullanıcıya gösterir.

Örnek payload:

```sql
' OR 1=1 --
```

Özellikleri:

* En hızlı veri sızdırılan türdür
* Hata mesajları sayesinde keşfi kolaydır
* Güncel sistemlerde daha nadir görülür ama hâlâ mevcuttur

---

### 2. UNION Based SQL Injection

Başka tabloların içeriğini çekmek için kullanılır.

Örnek:

```sql
' UNION SELECT username, password FROM users --
```

Amaç:

* Kolon sayısını öğrenmek
* Hangi kolonların ekrana basıldığını tespit etmek
* Hassas verileri çekmek

#### ORDER BY Neden Kullanılır?

`ORDER BY`, burada veri sıralamak için değil, **kolon sayısını öğrenmek için** kullanılır.

Örnek denemeler:

* `ORDER BY 1`
* `ORDER BY 2`
* `ORDER BY 3`

Eğer `ORDER BY 4` denendiğinde hata alınıyorsa, sorguda **3 kolon** vardır.
Bu yöntem, UNION saldırısından önce kolon sayısını güvenli şekilde tespit etmek için sıkça kullanılır.

---

### 3. Blind SQL Injection

Uygulama:

* Hata mesajlarını göstermez
* Sorgu sonucunu kullanıcıya basmaz

Bu durumda saldırgan, veriyi **doğrudan değil**, uygulamanın **davranışlarını** gözlemleyerek elde eder.

Alt türleri:

* Boolean-Based
* Time-Based
* Out-of-Band (OAST)

#### “Hiçbir şey görünmüyorsa saldırı nasıl anlaşılır?”

Blind SQLi’de saldırgan şunlara bakar:

* Sayfa içeriği değişiyor mu?
* HTTP response süresi uzuyor mu?
* HTTP status code farklı mı dönüyor?

#### Time-Based Örnek

```sql
' OR IF(1=1, SLEEP(5), 0) --
```

Eğer sayfa yaklaşık 5 saniye gecikiyorsa, SQL Injection vardır.

---

## SQL Mantığı Nasıl Bozulur?

SQL Injection’ın özü, **SQL’in mantıksal yapısını kırmaktır**.
Bunu sağlayan temel karakterler:

* `'` → String kapatır
* `--` → Sorgunun kalanını yorum satırı yapar
* `OR` → Koşulu her zaman true yapabilir

Bu karakterlerin yanlış kullanımı, sorgunun geliştiricinin amaçladığından tamamen farklı çalışmasına neden olur.

---

## Zafiyetli Flask + MySQL Örneği

❌ **GÜVENSİZ KOD**

```python
from flask import Flask, request
import mysql.connector

app = Flask(__name__)

db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="testdb"
)

@app.route("/login", methods=["POST"])
def login():
    username = request.form["username"]
    password = request.form["password"]

    cursor = db.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    cursor.execute(query)

    if cursor.fetchone():
        return "Giriş başarılı"
    return "Hatalı bilgiler"

app.run(debug=True)
```

### Bu Kod Neden Tehlikeli?

* Kullanıcı girdisi doğrudan SQL’e ekleniyor
* String birleştirme (`f-string`) kullanılıyor
* Sorgu yapısı kullanıcı tarafından değiştirilebiliyor

---

### Güvenli Versiyon (Prepared Statement)

```python
query = "SELECT * FROM users WHERE username = %s AND password = %s"
cursor.execute(query, (username, password))
```

Burada:

* SQL sorgusu sabit
* Kullanıcı girdisi sadece **veri**
* Payload SQL mantığını bozamaz

---

## ORM Kullanımı

ORM (Object Relational Mapping):

* SQL yazmadan veritabanı ile çalışmayı sağlar
* Parametrized query’leri otomatik üretir
* SQL Injection riskini ciddi ölçüde azaltır

⚠️ Ancak:

* `raw()`
* `execute()`
* Dinamik SQL

kullanıldığında risk geri gelir.

---

## SQL Injection Nasıl Tespit Edilir?

Sık kullanılan yöntemler:

* `'` karakteri gönderip hata gözlemlemek
* Boolean farkları (`AND 1=1` / `AND 1=2`)
* Time-Based gecikmeler
* SQLMap gibi otomatik araçlar (test ortamlarında)

---

## Savunma: Ne Yapılmalı / Ne Yapılmamalı

### İşe Yarar

* Prepared statements
* Parametrized queries
* ORM (doğru kullanım)
* Minimal yetki prensibi
* WAF (ek katman)
* SAST / DAST testleri

### İşe Yaramaz (Tek Başına)

❌ Sadece input validation
❌ `'` veya `OR` filtrelemek

Gerçek çözüm **SQL mimarisini güvenli kurmaktır**, input’u yasaklamak değil.

---

## Veritabanı Farkları (Kısa)

* **MySQL:** `SLEEP(5)`
* **MSSQL:** `WAITFOR DELAY '00:00:05'`
* **PostgreSQL:** `pg_sleep(5)`

Mantık aynıdır, syntax değişir.

---

## Framework Karşılaştırması (Özet)

* **Django:** ORM güvenli, `raw()` riskli
* **Flask:** Parametrized query şart
* **Express:** `query(text, params)` kullanılmalı
* **PHP:** PDO + prepared statement
* **.NET:** `SqlParameter` / Entity Framework

---

## Yaygın Senaryolar

* Login bypass
  `admin' --`

* Tüm kayıtları çekme
  `' OR 1=1 --`

* Tablo keşfi
  `' UNION SELECT table_name, null FROM information_schema.tables --`

# SQL Injection

## SQL Injection Nedir?

SQL Injection, bir web uygulamasının kullanıcıdan aldığı verileri **doğrudan SQL sorgusu içine eklemesi** sonucu ortaya çıkan kritik bir güvenlik açığıdır.

Bu açık sayesinde saldırgan:

* Yetkisiz verilere erişebilir
* Kimlik doğrulamayı atlatabilir
* Verileri silebilir veya değiştirebilir
* Bazı durumlarda veritabanı üzerinden sisteme daha derin erişim elde edebilir

SQL Injection, **OWASP Top 10** listesinde yıllardır yer alan ve pratikte hâlâ sıkça karşılaşılan bir zafiyettir. Bunun sebebi, hatanın genellikle kodun “çalışıyor” görünmesine rağmen **mantıksal olarak yanlış** olmasıdır.

---

## SQL Injection Gerçek Hayatta Nerelerde Çıkar?

Yeni başlayanların en çok sorduğu soru şudur:

> “Tamam anladım ama ben bunu nerede görürüm?”

Cevap net:

**Kullanıcıdan veri alıp veritabanına gönderen her yer potansiyel hedeftir.**

En sık görülen alanlar:

* Login formları (username / password)
* Arama kutuları (`?q=`)
* URL parametreleri (`?id=1`)
* Filtreleme ve sıralama alanları (`?sort=price`)
* API endpoint’leri
* API body parametreleri (JSON içindeki alanlar)
* Admin panelleri
* Raporlama, export/import, CSV işleme bölümleri

Kısaca:
**Input SQL’e gidiyorsa, SQL Injection ihtimali vardır.**

Bu bakış açısı konunun zihinde yerine oturmasını sağlar.

---

## SQL Injection Nasıl Çalışır?

Tipik bir login sorgusu:

```sql
SELECT * FROM users 
WHERE username = 'kullanici' AND password = 'sifre';
```

Sorun şudur:

> **Kullanıcıdan gelen veri, hiçbir ayrıştırma yapılmadan SQL sorgusunun parçası hâline gelmiştir.**

Saldırgan şu payload’u gönderirse:

```text
' OR '1'='1
```

Gerçek sorgu şuna dönüşür:

```sql
SELECT * FROM users 
WHERE username = '' OR '1'='1' AND password = '';
```

`'1'='1'` her zaman **true** olduğu için parola kontrolü devre dışı kalır.

Sonuç: **Login bypass**

---

## SQL Injection Türleri

### 1. In-Band SQL Injection

Uygulama:

* SQL hatalarını gösterir
* Sorgu sonucunu kullanıcıya basar

Örnek payload:

```sql
' OR 1=1 --
```

Özellikleri:

* En hızlı exploit edilen türdür
* Tespiti kolaydır
* Güncel sistemlerde daha az ama hâlâ görülür

---

### 2. UNION Based SQL Injection

Başka tablolardan veri çekmek için kullanılır.

```sql
' UNION SELECT username, password FROM users --
```

Amaç:

* Kolon sayısını öğrenmek
* Hangi kolonların ekrana basıldığını tespit etmek
* Hassas verileri çekmek

#### ORDER BY Neden Denir?

Yeni başlayanların en çok kaçırdığı nokta burasıdır.

`ORDER BY` burada veri sıralamak için **kullanılmaz**.
Amaç **kolon sayısını bulmaktır**.

```sql
' ORDER BY 1 --
' ORDER BY 2 --
' ORDER BY 3 --
```

* Hata yoksa → o kadar kolon vardır
* Hata aldığın yerde → kolon sayısını aşmışsındır

Bu bilgi olmadan UNION yapmak **ezber** olur, mantık oturmaz.

---

### 3. Blind SQL Injection

Uygulama:

* Hata mesajlarını gizler
* Sorgu sonucunu kullanıcıya göstermez

#### “Hiçbir şey görünmüyorsa saldırı nasıl yapılır?”

Blind SQL Injection’da saldırgan **veriyi değil**,
**uygulamanın davranışını** gözlemler.

Örnek gözlemler:

* Sayfa içeriği değişiyor mu?
* HTTP response süresi uzuyor mu?
* HTTP status code farklı mı?

Alt türleri:

* Boolean-Based
* Time-Based
* Out-of-Band (OAST)

#### Time-Based Örnek

```sql
' OR IF(1=1, SLEEP(5), 0) --
```

Sayfa 5 saniye gecikirse → SQL Injection vardır.

---

## SQL Mantığı Nasıl Bozulur?

SQL Injection’ın özü **SQL mantığını kırmaktır**.

Kritik karakterler:

* `'` → String kapatır
* `--` → Sorgunun kalanını yorum satırı yapar
* `OR` → Koşulu her zaman true yapabilir

Yanlış kullanıldığında sorgu geliştiricinin amacından tamamen çıkar.

---

## Zafiyetli Flask + MySQL Uygulaması

❌ **GÜVENSİZ KOD**

```python
from flask import Flask, request
import mysql.connector

app = Flask(__name__)

db = mysql.connector.connect(
    host="localhost",
    user="root",
    password="root",
    database="testdb"
)

@app.route("/login", methods=["POST"])
def login():
    username = request.form["username"]
    password = request.form["password"]

    cursor = db.cursor()
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    cursor.execute(query)

    if cursor.fetchone():
        return "Giriş başarılı"
    return "Hatalı bilgiler"

app.run(debug=True)
```

### Bu Kod Nerede Açık?

Red team gözüyle bakarsak:

```python
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
```

Burada olan şey şudur:

* SQL sorgusu **string olarak birleştiriliyor**
* Kullanıcı girdisi sorgunun **bir parçası hâline geliyor**
* Saldırgan sadece veri değil, **SQL mantığı gönderiyor**

Bu noktada saldırgan:

* `'` ile string kapatır
* `OR` ile koşulu değiştirir
* `--` ile password kontrolünü iptal eder

Uygulama şunu ayırt edemez:

> “Bu gelen şey kullanıcı adı mı, SQL mi?”

---

## Secure Versiyon (Prepared Statement)

✅ **GÜVENLİ KOD**

```python
@app.route("/login", methods=["POST"])
def secure_login():
    username = request.form["username"]
    password = request.form["password"]

    cursor = db.cursor(prepared=True)
    query = "SELECT * FROM users WHERE username = %s AND password = %s"
    cursor.execute(query, (username, password))

    if cursor.fetchone():
        return "Giriş başarılı"
    return "Hatalı bilgiler"
```

### Burada Ne Değişti?

* SQL sorgusu **önceden tanımlı ve sabit**
* Kullanıcı girdisi SQL’in **yapısına karışamaz**
* Veritabanı input’u **sadece veri** olarak işler

Saldırgan şunu gönderse bile:

```text
' OR 1=1 --
```

Veritabanı bunu:

> “Bu bir string, SQL değil”

olarak algılar.

**SQL Injection kapanmıştır.**

---

## ORM Kullanımı
## ORM Nedir?

<img width="856" height="445" alt="orm" src="https://github.com/user-attachments/assets/30bc2a2e-d175-4d57-8029-a3897021c12f" />


ORM (Object Relational Mapping), **veritabanı tablolarını uygulama içindeki nesnelere (class)** dönüştüren bir yaklaşımdır.

Yani ORM şunu yapar:

* Veritabanı Tablosu → Class
* Tablo Satırı → Object
* Kolon → Object Attribute

Geliştirici SQL yazmak yerine **nesnelerle çalışır**, ORM arka planda güvenli SQL sorgularını üretir.

---

### SQL Yazmadan Veri Çekme Mantığı

Klasik SQL ile:

```sql
SELECT * FROM users WHERE username = 'admin';
```

ORM ile aynı işlem:

```python
user = User.query.filter_by(username="admin").first()
```

Burada geliştirici SQL yazmaz.
ORM bunu **parametrized** ve güvenli bir SQL sorgusuna çevirir.

---

### ORM Neden SQL Injection’a Karşı Güvenlidir?

* SQL string olarak birleştirilmez
* Parametre binding otomatik yapılır
* Kullanıcı girdisi SQL mantığına karışamaz
* `' OR 1=1 --` gibi payload’lar **sadece string** olarak algılanır

Bu yüzden ORM doğru kullanıldığında SQL Injection riski **pratikte yoktur**.

---

### ORM Ne Zaman Tehlikelidir?

ORM kullanılıyor olması **tek başına yeterli değildir**.

Aşağıdaki kullanım **tehlikelidir**:

```python
db.session.execute(
    f"SELECT * FROM users WHERE username = '{username}'"
)
```

Bu noktada:

* ORM bypass edilir
* SQL tekrar string olarak birleştirilir
* SQL Injection riski **geri gelir**

---

ORM (Object Relational Mapping):

* Tablo → Class
* Satır → Object
* Kolon → Attribute

```python
user = User.query.filter_by(username=username).first()
```

ORM bunu arka planda güvenli SQL’e çevirir:

```sql
SELECT * FROM users WHERE username = %s LIMIT 1;
```

### ORM Ne Zaman Risklidir?

```python
db.session.execute(
    f"SELECT * FROM users WHERE username = '{username}'"
)
```

Burada ORM bypass edilir ve **SQL Injection geri gelir**.

---

## SQL Injection Nasıl Anlaşılır?

### In-Band

* SQL hatası görünür
* Veri ekrana basılır

### UNION-Based

* ORDER BY ile kolon sayısı bulunur
* UNION çalışıyorsa veri çekilir

### Blind

* Sayfa davranışı değişir
* Gecikme oluşur

---

## Ne Yapılmalı / Ne İşe Yaramaz

### İşe Yarar

* Prepared Statements
* Parametrized Queries
* ORM (doğru kullanım)
* Minimal DB yetkileri
* WAF (ek katman)

### ❌ Ne İşe Yaramaz

* Sadece input validation
* `'` engellemek
* `OR` silmek

**Gerçek çözüm SQL mimarisini güvenli kurmaktır.**

---

## Veritabanı Farkları (Mini Not)

Payload’lar veritabanına göre değişir:

* **MySQL:** `SLEEP(5)`
* **MSSQL:** `WAITFOR DELAY '00:00:05'`
* **PostgreSQL:** `pg_sleep(5)`

Mantık aynıdır, **syntax değişir**.

---

## Framework Davranışları (Özet)

* **Django:** ORM güvenli, `raw()` riskli
* **Flask:** Parametrized query şart
* **Express (Node.js):** `query(text, params)` kullanılmalı
* **PHP:** PDO + prepared statement
* **.NET:** Entity Framework / SqlParameter

---

## Yaygın Senaryolar

* Login bypass
  `admin' --`

* Tüm kayıtları çekme
  `' OR 1=1 --`

* Tablo keşfi
  `' UNION SELECT table_name, null FROM information_schema.tables --`

---

## Sonuç

* SQL Injection hâlâ gerçektir
* Input validation tek başına çözüm değildir
* Prepared statement ve ORM en güçlü savunmadır
* DB ve framework farkları bilinmelidir

Bu konuyu anlayan biri **ezber payload yazmaz**,
**mantığı görür**.

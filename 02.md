# SQL Injection — Genişletilmiş ve Uygulamalı Rehber

> Bu dosya, başlangıç seviyesinden red‑team uygulamalarına kadar SQL Injection konusunu açıklar. İsteğe göre eğitim materyali, not veya kılavuz olarak kullanılabilir.

---

## İçindekiler
1. [SQL Injection Nedir?](#sql-injection-nedir)
2. [Bu Açık Gerçekte Nerelerde Çıkar?](#bu-açık-gerçekte-nerelerde-çıkar)
3. [SQL Injection Nasıl Çalışır?](#sql-injection-nasıl-çalışır)
4. [Türler ve Nasıl Anlaşılır?](#türler-ve-nasıl-anlaşılır)
5. [ORDER BY Neden Denenir? (Kolon Sayısı Tespiti)](#order-by-neden-denenir-kolon-sayısı-tespiti)
6. [Blind SQLi — Niye Hiçbir Şey Görünmüyor?](#blind-sqli--niye-hiçbir-şey-görünmüyor)
7. [Ne İşe Yaramaz? — Yanlış Güvenlik Varsayımları](#ne-işe-yaramaz--yanlış-güvenlik-varsayımları)
8. [Veritabanı Türlerine Göre Farklılıklar (MySQL / MSSQL / PostgreSQL / Oracle)](#veritabanı-türlerine-göre-farklılıklar-mysql--mssql--postgresql--oracle)
9. [Framework / Kütüphane Davranışları (Örnekler)](#framework--kütüphane-davranışları-örnekler)
10. [Güvenli Kod Örnekleri ve En İyi Uygulamalar](#güvenli-kod-örnekleri-ve-en-iyi-uygulamalar)
11. [Hızlı Payload Cheat Sheet (Eğitim Amaçlı)](#hızlı-payload-cheat-sheet-eğitim-amaçlı)
12. [Güvenli Test İçin Notlar ve Etik Uyarı](#güvenli-test-için-notlar-ve-etik-uyarı)
13. [Kaynak/İleri Okuma Önerileri](#kaynakileri-okuma-önerileri)

---

## SQL Injection Nedir?
SQL Injection, bir uygulamanın **kullanıcı girdisini doğrudan SQL sorgusuna eklemesi** sonucu saldırganın SQL mantığını manipüle edebilmesiyle ortaya çıkan güvenlik açığıdır. Sonuçlar: veri sızıntısı, yetki atlatma, veri silme/düzeltme, hatta RCE'ye (doğrudan olmasa da zincirleme) zemin hazırlanması.

---

## Bu Açık Gerçekte Nerelerde Çıkar?
Kısa cevap: **Kullanıcıdan veri alan ve veritabanına gönderen her yer** potansiyel hedeftir. Örnekler:
- Login formları (username, password)
- Arama kutuları (ör. `?q=term`)
- URL parametreleri (ör. `?id=1`)
- Filtreleme / sıralama alanları (ör. `?sort=price`)
- API query parametreleri (GET parametreleri)
- API body parametreleri (JSON içinde gelen alanlar)
- Header veya cookie içerikleri (özellikle custom headerlar)
- Dosya yükleme metadata’sı (ör. filename değerleri)
- Admin panellerindeki filtreler ve rapor sorguları

Kısaca: kullanıcı girdisi uygulama tarafından veritabanına gönderiliyorsa dikkat edin.

---

## SQL Injection Nasıl Çalışır?
(Özet) Girdi sorgu yapısına karıştığında saldırgan SQL mantığı yazar. Temel kontrol karakterleri:
- `'` — string kapatma
- `--` veya `/* ... */` — yorum satırı
- `OR`, `AND` — mantıksal koşullar
- `;` — bazı RDBMS'lerde birden fazla sorgu ayırma (genelde uygulama katmanında devre dışı)

Örnek login bypass:
```
' OR '1'='1
```

---

## Türler ve Nasıl Anlaşılır?
- **In‑Band (Error / Voiced):** Hata mesajı veya veri doğrudan döner.
- **UNION‑Based:** `UNION SELECT` ile başka tabloların verisi sayfaya yansıtılır.
- **Blind (Boolean / Time):** Hata/veri yok; uygulama davranışı (sayfa farklı mı, gecikme var mı) gözlemlenir.
- **Out‑of‑Band (OOB / OAST):** Veri veya etki uygulama dışına (DNS, HTTP callback) gönderilir.

Belirti‑testleri örnekleri rehberin ilgili bölümünde.

---

## ORDER BY Neden Denenir? (Kolon Sayısı Tespiti)
`ORDER BY` burada **veriyi sıralamak için değil**, **sorguda kaç kolon olduğunu keşfetmek** için kullanılır.
- `ORDER BY 1` → Sorguda en az 1 kolon var mı?
- `ORDER BY 2` → En az 2 kolon var mı?
- Hata alınan `ORDER BY n` denemesinde, `n` sütun sayısını aşıyordur.
Neden önemli? `UNION SELECT` ile veri çekerken `UNION`'daki kolon sayısının hedef sorguyla eşleşmesi gerekir. `ORDER BY` basit ve güvenli bir yöntemdir kolon sayısını bulmaya.

---

## Blind SQLi — Niye Hiçbir Şey Görünmüyor?
Blind SQL Injection'da uygulama **hata mesajlarını gizler** veya sonuçları göstermez. Bu yüzden:
- Sorgu sonucunu doğrudan göremezsiniz.
- Saldırgan **veri** değil, **uygulamanın davranışını** gözlemler.
  - Boolean‑based: Farklı koşullar sayfa içeriğini değiştirir → true/false çıkarımı
  - Time‑based: `SLEEP()` veya `WAITFOR DELAY` ile gecikme ölçülür
Bu farkı anlamak, saldırı tekniğini seçmek için kritiktir.

---

## Ne İşe Yaramaz? — Yanlış Güvenlik Varsayımları
**Yanlış:** Sadece input validation/karakter filtreleme yapmak yeterlidir.  
**Neden yetmez?**
- Basit `'` engelleme veya `OR` kaldırma, saldırganın farklı yollarla sorgu mantığını değiştirmesini engellemez.
- URL encode/decode, farklı veri tipleri, unicode/encoding trick'leri atlatabilir.
**Doğru çözüm örnekleri:**
- ✔ Prepared Statements / Parameterized Queries
- ✔ Güçlü ORM kullanımı (ve yanlış raw SQL kullanımına dikkat)
- ✔ En düşük ayrıcalıklı DB kullanıcısı
- ✔ Hata mesajlarını gizleme / merkezi loglama
- ✔ Input validation *ekstra* bir önlem olarak kullanılmalı, tek savunma olmamalı

---

## Veritabanı Türlerine Göre Farklılıklar
> Not: Mantık aynıdır ama syntax ve fonksiyonlar değişir — payload'lar veritabanına göre uyarlanmalıdır.

### MySQL
- Gecikme fonksiyonu: `SLEEP(seconds)`
- Limit: `LIMIT offset, count`
- Information schema: `information_schema.tables`, `information_schema.columns`
- Boolean ifadeler genelde `IF(condition, true, false)` veya `CASE WHEN`

### Microsoft SQL Server (MSSQL)
- Gecikme: `WAITFOR DELAY '00:00:05'`
- TOP kullanım: `SELECT TOP 1 ...`
- Sistem tabloları: `sys.objects`, `INFORMATION_SCHEMA.TABLES`
- String concatenation farklı olabilir (`+`)

### PostgreSQL
- Gecikme: `pg_sleep(seconds)`
- LIMIT desteği `LIMIT`
- Sistem katalogu: `pg_catalog`, `information_schema`
- Boolean / casting davranışları biraz farklı; fonksiyon adları değişir

### Oracle
- Gecikme: özel; `DBMS_LOCK.SLEEP` gibi prosedür çağrıları gerekebilir (yetkiye bağlı)
- Sistem tabloları: `ALL_TABLES`, `USER_TABLES`
- `ROWNUM` veya modern sürümlerde `FETCH FIRST n ROWS` kullanılır

**Pratik sonuç:** Bir payload'ı diğerine doğrudan kopyalamadan önce RDBMS'e göre `sleep/limit/top/system tables` gibi parçaları uyarlayın.

---

## Framework / Kütüphane Davranışları (Örnekler)
Aşağıda popüler frameworklerin tipik davranışları ve saldırı yüzeyleri:

### Flask (Python) + plain MySQL driver
- Eğer sorgu string olarak birleştiriliyorsa (f-strings, `%` format) **açık**.
- `mysql-connector` veya `pymysql` ile parametre kullanın: `cursor.execute(query, (param,))`.

### Django (Python)
- Django ORM, parametre binding yapar — **varsayılan olarak güvenlidir**.
- Ancak `raw()` veya `extra()` kullanımı dikkat gerektirir. `Raw SQL` yazarken parametre binding kullanın.

### SQLAlchemy (Python)
- ORM ve core tarafı parametre binding sağlar. `text()` ile raw SQL yazarken `bindparams` kullanın.

### Express (Node.js) + mysql / mysql2
- `connection.query('SELECT ... ' + req.query.q)` tarzı kullanım tehlikelidir.
- `connection.query('SELECT * FROM users WHERE id = ?', [id])` şeklinde parametreleyin.

### ASP.NET (C#)
- `SqlCommand` ile parametreleri kullanın (`@param`).
- String concat ile SQL oluşturmayın.

### Ruby on Rails (ActiveRecord)
- `Model.where(name: params[:name])` güvenli.
- `Model.where("name = '#{params[:name]}'")` gibi interpolation tehlikeli.

### PHP (PDO / mysqli)
- PDO ile `prepare` + `execute` kullanılmalı.
- `mysqli_query($conn, $sql)` ile doğrudan gömme yapılmamalı.

**Genel tavsiye:** Hangi framework olursa olsun ORM / driver’ın parametreli API’si kullanılmalı; raw SQL gerekiyorsa mutlaka parametre binding yapılmalı.

---

## Güvenli Kod Örnekleri ve En İyi Uygulamalar

### Python (mysql-connector) — güvenli
```python
query = "SELECT * FROM users WHERE username = %s AND password = %s"
cursor.execute(query, (username, password))
```

### Node.js (mysql2) — güvenli
```js
connection.execute('SELECT * FROM users WHERE id = ?', [userId], (err, rows) => { ... });
```

### C# (ADO.NET) — güvenli
```csharp
using (SqlCommand cmd = new SqlCommand("SELECT * FROM Users WHERE Id=@id", conn)) {
    cmd.Parameters.AddWithValue("@id", id);
    using (SqlDataReader reader = cmd.ExecuteReader()) { ... }
}
```

### En İyi Uygulamalar (Özet)
- Prepared statements / Parameter binding
- ORM tercih edin ama raw SQL’e dikkat
- Least privilege (DB user minimal yetki)
- Hata mesajlarını kullanıcılara vermeyin; loglayın
- WAF, IPS gibi ek savunmalar
- Girdi tipini ve uzunluğunu doğrulayın — ama tek başına güvenlik değildir
- Kod incelemesi ve güvenlik testleri (DAST/SAST) düzenli yapın

---

## Hızlı Payload Cheat Sheet (Eğitim Amaçlı)
> Uyarı: Bu örnekler yalnızca eğitim/defensive amaçlı kullanılmalıdır.

- Login bypass (in‑band):
```
' OR '1'='1' --
```
- Kolon sayısı tespiti:
```
' ORDER BY 1 --
' ORDER BY 2 --
```
- UNION test (örnek iki kolonlu sayfa için):
```
' UNION SELECT null, version() --
```
- Time‑based (MySQL):
```
' OR IF(1=1, SLEEP(5), 0) --
```
- Time‑based (MSSQL):
```
' WAITFOR DELAY '00:00:05' --
```

---

## Güvenli Test İçin Notlar ve Etik Uyarı
- Yalnızca izinli sistemlerde test yapın. İzin yoksa **yasal sorun** çıkartır.
- Laboratuvarlar: PortSwigger Web Security Academy, DVWA, OWASP Juice Shop gibi kontrollü ortamlar kullanın.
- Testleri üretim üzerinde doğrudan çalıştırmayın; logları ve performansı etkileyebilir.

---

## Kaynak / İleri Okuma Önerileri
- OWASP Top 10 ve OWASP Web Security Testing Guide
- PortSwigger Web Security Academy
- Veritabanı vendor dokümantasyonları (MySQL, MSSQL, PostgreSQL, Oracle)
- Resmi framework dokümantasyonları (Django, Rails, Express, ASP.NET)

---

## Son Not
Bu rehber eğitim amaçlı ve öğrenci/danışmanlık kullanımına uygundur. İstersen bu .md dosyasını daha kısa bir özet, slayt seti ya da eğitim el kitabına dönüştürebilirim.

